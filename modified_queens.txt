'''This module implements a version of the N-Queens problem suitable
for use with local search algorithms such as hill-climbing.  The
hill_climbing function provided in the textbook code repository is
also included here, modified very slightly so that we can obtain the
list of actions taken to reach the local maximum found by the
function.

'''

# Uncomment the code below to run from a subdirectory rather than in
# aima-python itself.

#import sys
#sys.path.insert(0, '..')  # Assume textbook code is in parent directory.

# Also need to copy 'images' directory if running from a subdirectory.


import random
from search import *   # Textbook's search.py.
                       # Using NQueensProblem and Node.
from utils import argmax_random_tie                       
from notebook import plot_NQueens
# Needed to hide warnings in the matplotlib sections
import warnings
warnings.filterwarnings("ignore")

''' Copied hill_climbing function from search.py so that it could be
modified slightly.  The only change is to return 'current', which is a
search Node, rather than returning only the state that the Node
contains.  Returning the full Node gives us access to the list of
actions leading from the initial state to the search algorithm's
solution. '''
def hill_climbing(problem):
    """
    [Figure 4.2]
    From the initial node, keep choosing the neighbor with highest value,
    stopping when no neighbor is better.
    """
    current = Node(problem.initial)
    while True:
        neighbors = current.expand(problem)
        print('length of neighbors', len(neighbors))
        if not neighbors:
            break
        neighbor = argmax_random_tie(neighbors,
                                     key=lambda node: problem.value(node.state))
        if problem.value(neighbor.state) <= problem.value(current.state):
            break
        current = neighbor
    return current # Only change from original, which returned current.state

def compute_value(state, problem):
    return problem.value(state)

def stochastic_hill_climbing(problem):
    current = Node(problem.initial)
    while True:
        current_value = compute_value(current.state, problem)
        neighbors = current.expand(problem)
        better_neighbors = [neighbor for neighbor in neighbors if compute_value(neighbor.state, problem) > current_value]
        #print('better_neighbors', len(better_neighbors))
        if not better_neighbors:
            break
        neighbor = random.choice(better_neighbors)
        if problem.value(neighbor.state) <= problem.value(current.state):
            break
        current = neighbor
    return current 


def stochastic_hill_climbing2(problem):
    current = Node(problem.initial)
    while True:
        neighbors = current.expand(problem)
        _length = len(neighbors)
        if not neighbors: 
            break
        random_number = random.randint(0, _length-1)
        neighbor = neighbors[random_number]
        if problem.value(neighbor.state) <= problem.value(current.state):
            break
        current = neighbor
    return current

class LocalSearchNQueensProblem(NQueensProblem):
    '''Local search version of NQueensProblem.

    Search state is a tuple of N ints in the range 0..N-1.
    Each tuple entry represents a column and the entry's value is the row 
    of the queen within that column.
    This search state space is compatible with (is a subset of) the search 
    space of the NQueensProblem class. So we are able to inherit several
    methods from that class.'''

    def __init__(self, N, seed=None):
        '''Initializes the instance variables.

        Instance variable 'initial' will represent a board (search
        state) with one queen randomly placed in each column.

        Args:
            N: Integer size of one dimension of the square board.
            seed: Integer random number seed.  If not supplied, default 
                random number generation is used.

        '''
        super().__init__(N)
        
        # Replace the initial board generated by the superclass---an
        # empty board---with one appropriate for our purposes of
        # complete-state search. Specifically, we want to begin with a
        # board having one queen placed randomly in each column.
        random.seed(seed)
        self.initial = tuple( random.randrange(N) for _ in range(N) ) 

    def actions(self, state):
        '''Yields the valid actions from the given state.

        Action is a tuple, (col,row), indicating that the queen in
        column 'col' moves to row 'row'.  There are therefore N*(N-1)
        possible actions.

        Args:
            state: The search state from which we want to generate actions.

        Yields:
            One of the valid actions that can be taken from the given state.

        '''
        for col, row in enumerate(state):
            for i in range(row):
                yield (col, i)
            for i in range(row+1,self.N):
                yield (col, i)

    def result(self, state, action):
        '''Determines state that results when action is applied to state.

        Args:
            state: The search state to which the action will be applied.
            action: The action to be applied.  Action is a tuple (col, row).

        Returns:
            State produced by changing the given state according to the
               (col, row) information of the given action, specifically,
               changing the col value within given state to the given row.
        '''
        (col, row) = action
        return state[:col] + (row,) + state[col+1:]

    def value(self, state):
        '''Computes value to be maximized by local search algorithm.  

        For this value we will use the negative of the number of pairs
        of queens that are attacking each other.

        Args:
            state: The search state for which the number of attacking pairs
                of queens will be calculated.

        Returns:
            Negative of number of pairs of attacking queens in given state.

        '''
        return -self.h(Node(state))//2

    def __repr__(self):
        return f'Local Search {self.N} Queens'

def main():
    '''An example program that runs hill-climbing once on the N-Queens
    problem and produces various outputs.  It then runs hill-climbing
    1000 times and produces counts of the number of times the global
    maximum is reached and the total number of actions executed.

    '''
    N = 8
    problem = LocalSearchNQueensProblem(N)
    print()
    print(f'*** {N}-Queens problem ***')
    print(f'Initial state (row of queen in each column): {problem.initial}')
    actions = problem.actions(problem.initial)
    actions_list = list(actions) # actions() returns a generator;
                                 # convert to list for convenient access
    print(f'{len(actions_list)} possible (col, row) actions from initial state:')
    print(actions_list)
    print(f'Example: state resulting from applying first action to initial state: {problem.result(problem.initial, actions_list[0])}')
    print(f'Initial number of pairs of attacking queens: {-problem.value(problem.initial)}')
    #local_maximum_node = stochastic_hill_climbing(problem)
    #local_maximum = local_maximum_node.state
    local_maximum_node = stochastic_hill_climbing2(problem)
    local_maximum = local_maximum_node.state
    #local_maximum_node = hill_climbing(problem)
    #local_maximum = local_maximum_node.state
    print(f'Local maximum found by basic hill-climbing: {local_maximum}')
    print(f'Number of attacking pairs at local maximum: {-problem.value(local_maximum)}')
    print(f'Actions required: {local_maximum_node.solution()}')
    print('Plot of local maximum being displayed; close plot window to continue.')
    plot_NQueens(list(local_maximum))

    # v3
    # compare_searchers([problem], ['Searcher', '8-Queen'], [hill_climbing])
    # v4
    from search4e import report
    report_iterations = 1000
    print(f'Report based on {report_iterations} iterations:')
    report([hill_climbing],
           [LocalSearchNQueensProblem(N) for _ in range(report_iterations)],
           verbose=False)

def main1():
    N = 8
    problem = LocalSearchNQueensProblem(N)
    print()
    print(f'***{N}-Queens Problem***')
    print(f'Initial state of problem (row of queen in each col): {problem.initial}')
    actions = problem.actions(problem.initial)
    actions_list = list(actions)
    print(f'{len(actions_list)} possible (col, row) actions from initial state:')
    print(actions_list)
    print(f'Example: state resulting from applying first action to initial state: {problem.result(problem.initial, actions_list[0])}')
    print(f'Initial number of pairs of attack queens: {-problem.value(problem.initial)}')
    local_maximum_node = stochastic_hill_climbing(problem)
    local_maximum = local_maximum_node.state
    print(f'Local maximum found by stochastic hill-climbing: {local_maximum}')
    print(f'Number of attacking pairs at local maximum: {-problem.value(local_maximum)}')
    print(f'Actions required: {local_maximum_node.solution()}')
    print('Plot of local maximum being displayed; close plot window to continue.')
    plot_NQueens(list(local_maximum))

    from search4e import report
    report_iterations = 1000
    print(f'Report based on {report_iterations} iterations:')
    report([stochastic_hill_climbing],
           [LocalSearchNQueensProblem(N) for _ in range(report_iterations)],
           verbose = False)
    

if __name__ == "__main__":
    main1()
